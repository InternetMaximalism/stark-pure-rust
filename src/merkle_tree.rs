use crate::utils::{blake, is_a_power_of_2};
use std::convert::TryInto;

pub fn merklize(nodes: &[Vec<u8>]) -> Vec<Vec<u8>> {
  let n = nodes.len();
  assert!(is_a_power_of_2(n.try_into().unwrap()));

  let mut nodes_clone = nodes.to_vec();

  for i in 0..(n - 1) {
    let mut message = nodes_clone[2 * i].clone();
    message.extend(&nodes_clone[2 * i + 1]);
    let internal_hash = blake(&message);
    nodes_clone.push(internal_hash);
  }
  nodes_clone
}

#[test]
fn test_merklize() {
  let leaves: Vec<Vec<u8>> = vec![
    hex::decode("7fffffff").unwrap(),
    hex::decode("80000000").unwrap(),
    hex::decode("00000003").unwrap(),
    hex::decode("00000000").unwrap(),
  ];
  let merkle_tree = merklize(&leaves);
  assert_eq!(
    merkle_tree
      .iter()
      .map(|node| hex::encode(node))
      .collect::<Vec<String>>(),
    [
      "7fffffff",
      "80000000",
      "00000003",
      "00000000",
      "f086026887af5fd609b58ecc4fec9ad514dba2c6fed57078d1f40ba0b2ecc4ca",
      "bfc3f121b61735fb3ac096a730b5f52909dc6f76c681f74fa2d59cf54cc4c74d",
      "790c073cc04363a97b6db44efd32734264f1fa1e2fdf64a74cd9427bda4ab7da"
    ]
  );

  let leaves: Vec<Vec<u8>> = vec![vec![0x00, 0x00, 0x00, 0x01]];
  let merkle_tree = merklize(&leaves);
  assert_eq!(merkle_tree, [[0x00, 0x00, 0x00, 0x01]]);
}

pub fn get_root(tree: &[Vec<u8>]) -> Vec<u8> {
  tree[tree.len() - 1].clone()
}

pub fn mk_branch(tree: &[Vec<u8>], index: usize) -> Vec<Vec<u8>> {
  let mut tree_clone = tree.to_vec();
  tree_clone.push(vec![0, 0, 0, 0]);
  tree_clone.reverse();
  let mut index_clone = (tree.len() + 1) - 1 - index.clone();
  let mut proof = vec![tree_clone[index_clone].clone()];
  while index_clone > 1 {
    proof.push(tree_clone[index_clone ^ 1].clone());
    index_clone /= 2;
  }
  proof
}

pub fn verify_branch(root: &[u8], index: usize, proof: &[Vec<u8>]) -> Vec<u8> {
  let proof_size: usize = 2u32
    .pow(proof.len().try_into().unwrap())
    .try_into()
    .unwrap();
  let mut index_clone: usize = index.clone() + proof_size;
  let mut v = proof[0].clone();
  for i in 1..(proof.len()) {
    let mut message: Vec<u8> = vec![];
    if index_clone % 2 == 1 {
      message.extend(&proof[i]);
      message.extend(&v);
    } else {
      message.extend(&v);
      message.extend(&proof[i]);
    }
    v = blake(&message);
    index_clone /= 2;
  }

  assert_eq!(hex::encode(&v), hex::encode(root));
  proof[0].clone()
}

#[test]
fn test_single_proof() {
  let index = 2;
  let leaves: Vec<Vec<u8>> = vec![
    hex::decode("7fffffff").unwrap(),
    hex::decode("80000000").unwrap(),
    hex::decode("00000003").unwrap(),
    hex::decode("00000000").unwrap(),
  ];
  let merkle_tree = merklize(&leaves);
  let merkle_root = get_root(&merkle_tree);
  let proof = mk_branch(&merkle_tree, index);
  assert_eq!(
    proof
      .iter()
      .map(|node| hex::encode(node))
      .collect::<Vec<String>>(),
    [
      "00000003",
      "00000000",
      "f086026887af5fd609b58ecc4fec9ad514dba2c6fed57078d1f40ba0b2ecc4ca",
    ]
  );

  let res = verify_branch(&merkle_root, index, &proof);
  assert_eq!(res, leaves[index]);
}

#[test]
fn test2_single_proof() {
  let index = 11;
  let leaves: Vec<Vec<u8>> = [
    "000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "d5ff76a5acca4c8b2d9e84160f4b6fe9daa9d13a02bef4bbd8c5f40bba50e80becd013bd87d205920b870145de52f9e507c9cbd88c281418c1d980ce4c32281e0000000000000000000000000000000000000000000000000000000000000000",
    "000000000000000000000000000000000000000000000000000000000000004500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "2a00895a5335b374d2617be9f0b4901625562ec5fd410b44273a0a9545af183e132fec42782dfa6df478feba21ad061af836342773d7ebe73e267dd2b3ce2bad0000000000000000000000000000000000000000000000000000000000000000",
    "15f2d49286cdda4d91a46319711f5d768cc6f897b55ce32e86e57631e697cddda26ff34c670c0408d8af01353ce182e87b090d467e895f2d1a8bcebd8b74718a0000000000000000000000000000000000000000000000000000000000000000",
    "e89b30f4cae5f3d8c18ddedc75393d27a3975eb75789db46563008485451481c649f7ff67e4e087d7e34b324bdbd5475250d0bfb3c49f4a8544f25de0001a7a10000000000000000000000000000000000000000000000000000000000000000",
    "ea0d2b6d793225b26e5b9ce68ee0a289733907684aa31cd1791a886f1968326c3d15aa11d6b0ec2ab81ad343e86850a26bbe47d9ac789988c1ae2084d0309c0c0000000000000000000000000000000000000000000000000000000000000000",
    "1764cf0b351a0c273e7221238ac6c2d85c68a148a87624b9a9cff658abaeb82dbbdae2ab43f5074ef10178621cf8d7fff42b9ee498b412a1cf76e821a45c23e30000000000000000000000000000000000000000000000000000000000000000",
    "9b84e0131d976bca60e739610817d397357de90a723a6a7e63745572a62879f539eaa20b0e5f8189cc27db422e739516fbe90038ac7480d663a62297d727ede90000000000000000000000000000000000000000000000000000000000000000",
    "adc7c36fba3f0bb95e1519861681bcaa76d24927b5933a2e6681ecec1155218a6e062ff1a815f52da54da532a83215d5ef6c4aae24b291ae2c3e935124350ef10000000000000000000000000000000000000000000000000000000000000000",
    "647b1fece26894359f18c69ef7e82c68ca8216f58dc595819c8ba92e59d786541ea5f06ce081465c1538610fb1be4752ab50f03bf6ed58ff5829d0de04848a720000000000000000000000000000000000000000000000000000000000000000",
    "52383c9045c0f446a1eae679e97e4355892db6d84a6cc5d1997e11b4eeaadebf39693d96690942ec79521e7b779c0dc06959c4dd37eb947c17f177da002151cd0000000000000000000000000000000000000000000000000000000000000000",
    "c8d4e5d94ca9cd458dd0247593d385847f155f5dc3dbf62eef19a51db12f90956383cd90e772afe8d38ee956701846d52f17cd99284a985f8e44ede84bb713290000000000000000000000000000000000000000000000000000000000000000",
    "9b49d10b6ea5c401c484f0fd8361eed3dae42c1d7db1d21616234a917f717b6d916e67ce02cedca02907765af1b38b58b07fb3099d749aea15eec420d946ab2f0000000000000000000000000000000000000000000000000000000000000000",
    "372b1a26b35632ba722fdb8a6c2c7a7b80eaa0a23c2409d110e659834ed06fb41eef75e08c2b9104bcedefde142096e3e7d5ce90092068dc545175d33e04395e0000000000000000000000000000000000000000000000000000000000000000",
    "64b62ef4915a3bfe3b7b0f027c9e112c251bd3e2824e2de9e9dcb40f808e84dcec1e54c08992e272467bb0708a1396ee3892b0cd312063da077ad5659d00e1640000000000000000000000000000000000000000000000000000000000000000",
  ]
    .iter()
    .map(|node| hex::decode(node).unwrap())
    .collect();

  let merkle_tree = merklize(&leaves);
  let answer: Vec<_> = vec![
    "000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "d5ff76a5acca4c8b2d9e84160f4b6fe9daa9d13a02bef4bbd8c5f40bba50e80becd013bd87d205920b870145de52f9e507c9cbd88c281418c1d980ce4c32281e0000000000000000000000000000000000000000000000000000000000000000",
    "000000000000000000000000000000000000000000000000000000000000004500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "2a00895a5335b374d2617be9f0b4901625562ec5fd410b44273a0a9545af183e132fec42782dfa6df478feba21ad061af836342773d7ebe73e267dd2b3ce2bad0000000000000000000000000000000000000000000000000000000000000000",
    "15f2d49286cdda4d91a46319711f5d768cc6f897b55ce32e86e57631e697cddda26ff34c670c0408d8af01353ce182e87b090d467e895f2d1a8bcebd8b74718a0000000000000000000000000000000000000000000000000000000000000000",
    "e89b30f4cae5f3d8c18ddedc75393d27a3975eb75789db46563008485451481c649f7ff67e4e087d7e34b324bdbd5475250d0bfb3c49f4a8544f25de0001a7a10000000000000000000000000000000000000000000000000000000000000000",
    "ea0d2b6d793225b26e5b9ce68ee0a289733907684aa31cd1791a886f1968326c3d15aa11d6b0ec2ab81ad343e86850a26bbe47d9ac789988c1ae2084d0309c0c0000000000000000000000000000000000000000000000000000000000000000",
    "1764cf0b351a0c273e7221238ac6c2d85c68a148a87624b9a9cff658abaeb82dbbdae2ab43f5074ef10178621cf8d7fff42b9ee498b412a1cf76e821a45c23e30000000000000000000000000000000000000000000000000000000000000000",
    "9b84e0131d976bca60e739610817d397357de90a723a6a7e63745572a62879f539eaa20b0e5f8189cc27db422e739516fbe90038ac7480d663a62297d727ede90000000000000000000000000000000000000000000000000000000000000000",
    "adc7c36fba3f0bb95e1519861681bcaa76d24927b5933a2e6681ecec1155218a6e062ff1a815f52da54da532a83215d5ef6c4aae24b291ae2c3e935124350ef10000000000000000000000000000000000000000000000000000000000000000",
    "647b1fece26894359f18c69ef7e82c68ca8216f58dc595819c8ba92e59d786541ea5f06ce081465c1538610fb1be4752ab50f03bf6ed58ff5829d0de04848a720000000000000000000000000000000000000000000000000000000000000000", // branch
    "52383c9045c0f446a1eae679e97e4355892db6d84a6cc5d1997e11b4eeaadebf39693d96690942ec79521e7b779c0dc06959c4dd37eb947c17f177da002151cd0000000000000000000000000000000000000000000000000000000000000000", // target
    "c8d4e5d94ca9cd458dd0247593d385847f155f5dc3dbf62eef19a51db12f90956383cd90e772afe8d38ee956701846d52f17cd99284a985f8e44ede84bb713290000000000000000000000000000000000000000000000000000000000000000",
    "9b49d10b6ea5c401c484f0fd8361eed3dae42c1d7db1d21616234a917f717b6d916e67ce02cedca02907765af1b38b58b07fb3099d749aea15eec420d946ab2f0000000000000000000000000000000000000000000000000000000000000000",
    "372b1a26b35632ba722fdb8a6c2c7a7b80eaa0a23c2409d110e659834ed06fb41eef75e08c2b9104bcedefde142096e3e7d5ce90092068dc545175d33e04395e0000000000000000000000000000000000000000000000000000000000000000",
    "64b62ef4915a3bfe3b7b0f027c9e112c251bd3e2824e2de9e9dcb40f808e84dcec1e54c08992e272467bb0708a1396ee3892b0cd312063da077ad5659d00e1640000000000000000000000000000000000000000000000000000000000000000",

    "37b2efc67126ae8ab5598837195d9b9be56a44a5b3482c787dd30ee656867599",
    "c9a70a02956089b9396118326d04b73cff97a25fee0319125efbb8afb5212c4c",
    "0e1e269ef97801d162f18ca40f678154ec29b4131698b794ed1e942febca7892",
    "ac7037673a5e18893b09e2caf29ecc07b582374d2edb0c50ede286a8d5cd942f",
    "a65baca9ff73748f99c9945889d09d46fab29c558da4c46b38ce1421b0e7eb4d", // branch
    "a6c29d6f29b399988d7a52624199e85b33c99c2420d8764c00fa6630109cbd3f", // target
    "66a6d902a84689ba7aec8785d07c743490fe0d51a465d8554dfbb9dddc524b6d",
    "602d3917fa4b2998f3c17c251431cd19578b6dc73bd48e18d59369ca4f925021",

    "1e89e9fe074006fb1b0318cf54a77a155f57ba6db1a7fff0777ed854f180a7fa",
    "37b475adccf3fe8d6156bdcc2fcae314bfc43a1b2a5866ffeff089b1a590992c",
    "a2cd4f58befd63240d884353bb304ddb5bf8835099fbca92586a9d533c89692d", // target
    "3c8c492d5322a20f2b96a8d36346688311ef0da25bb187dd4f69e8b7a371a300", // branch

    "4eca2a96c40bdb860779a95198833fff633706d8fce2dc932c2f4e30b2920552", // branch
    "8bd3c57137c85cea0e509ce4b09ede0fd5658ddd8743bb13997a754c795b06d6", // target

    "6f8279bd0873c9fe0bb65712a105ec7b5fc9f5f952880777f4536847bd9b241c", // target
  ];
  assert_eq!(
    merkle_tree
      .iter()
      .map(|node| hex::encode(node))
      .collect::<Vec<String>>(),
    answer
  );
  let merkle_root = get_root(&merkle_tree);
  let proof = mk_branch(&merkle_tree, index);
  assert_eq!(
    proof
      .iter()
      .map(|node| hex::encode(node))
      .collect::<Vec<String>>(),
    ["52383c9045c0f446a1eae679e97e4355892db6d84a6cc5d1997e11b4eeaadebf39693d96690942ec79521e7b779c0dc06959c4dd37eb947c17f177da002151cd0000000000000000000000000000000000000000000000000000000000000000", "647b1fece26894359f18c69ef7e82c68ca8216f58dc595819c8ba92e59d786541ea5f06ce081465c1538610fb1be4752ab50f03bf6ed58ff5829d0de04848a720000000000000000000000000000000000000000000000000000000000000000", "a65baca9ff73748f99c9945889d09d46fab29c558da4c46b38ce1421b0e7eb4d", "3c8c492d5322a20f2b96a8d36346688311ef0da25bb187dd4f69e8b7a371a300", "4eca2a96c40bdb860779a95198833fff633706d8fce2dc932c2f4e30b2920552"]
  );
  let res = verify_branch(&merkle_root, index, &proof);
  assert_eq!(hex::encode(res), "52383c9045c0f446a1eae679e97e4355892db6d84a6cc5d1997e11b4eeaadebf39693d96690942ec79521e7b779c0dc06959c4dd37eb947c17f177da002151cd0000000000000000000000000000000000000000000000000000000000000000");
}

// #[test]
// fn test() {
//   let merkle_root = "0000000000000000f4e76e3dee4ddce644ba422b784611631d1254d65f130361885d4b2bf6f680d1";
//   let index = 4;
//   let proof = ["0000000000000000f94e2453893f8ac8f313384cd2ed3242d1d48e5885216f55e24ba863205c36ea", "0000000000000000c79c149c44e9c595884ba0d0c94bad6c8ad72fbaf72201cf95c8966edde56718", "fc0b5ef601c3b8a6660f989620c62981f09185cd295d1e93ad2464201c610ece", "66dc98792db40ea9be7b0e66d1845267fad437ec56560cf1564be3bc6828f26a", "e0eccc939e6a9eace8f464333d7fc28142b03a4047113300e9d2abe24b3900b3", "6fc04d080943c6bcdd4f314f19360bd9ab3c9959271c673490a57f1b30bfccd1", "25ec911996051c047390df15b46ae06ebed2894f3cca1b3192a45d312f9e0123", "e7c98abdf781e1143e82ec56125ed67bdb77a841567116ab8596728a2d2dc860", "77e2496afed96b9bffc6b86be5cb59cfee7396c8361cf29507f23469cac11e04", "07fe7c01bd9c96f5c68b435c6ef54b937d0b54497796226b1296f351e60526a6", "4288090a0f6b103d195137fe1a6f0d7ffeab6cc272a23e3cc1fb379fd1ef9798", "8d970ac6d4d883e4c185d4d37d357841262b9e867fe5ea934b2748e266bdc07f", "90a01fe4b135a1caaad32b623a7af75ba11f9881bee503dde3b2ae64ce4b156b", "1a85fed038396acf7ff7476bf42bfe56caea6a9a9c4a37b8e26fd8f0623a72ba", "c60eb5ffb60ec5d92b6271d82a64f6f948abbcfc52608f9754469cb736e34da5"]
//   let res = verify_branch(&merkle_root, index, &proof);
// }

pub fn mk_multi_branch(tree: &[Vec<u8>], indices: &[usize]) -> Vec<Vec<Vec<u8>>> {
  let mut proofs = vec![];
  for i in indices {
    let proof = mk_branch(tree, *i);
    proofs.push(proof);
  }

  proofs
}

pub fn verify_multi_branch(
  root: &[u8],
  indices: &[usize],
  proofs: &[Vec<Vec<u8>>],
) -> Vec<Vec<u8>> {
  indices
    .iter()
    .zip(proofs)
    .map(|(i, b)| verify_branch(root, *i, b))
    .collect()
}

#[test]
fn test_multi_proof() {
  let indices = [1, 2];
  let leaves: Vec<Vec<u8>> = vec![
    hex::decode("7fffffff").unwrap(),
    hex::decode("80000000").unwrap(),
    hex::decode("00000003").unwrap(),
    hex::decode("00000000").unwrap(),
  ];
  let merkle_tree = merklize(&leaves);
  let merkle_root = get_root(&merkle_tree);
  let proofs = mk_multi_branch(&merkle_tree, &indices);
  assert_eq!(
    proofs
      .iter()
      .map(|proof| proof
        .iter()
        .map(|node| hex::encode(node))
        .collect::<Vec<String>>())
      .collect::<Vec<Vec<String>>>(),
    [
      [
        "80000000",
        "7fffffff",
        "bfc3f121b61735fb3ac096a730b5f52909dc6f76c681f74fa2d59cf54cc4c74d"
      ],
      [
        "00000003",
        "00000000",
        "f086026887af5fd609b58ecc4fec9ad514dba2c6fed57078d1f40ba0b2ecc4ca",
      ],
    ]
  );

  let res = verify_multi_branch(&merkle_root, &indices, &proofs);
  let answer: Vec<Vec<u8>> = indices.iter().map(|index| leaves[*index].clone()).collect();
  assert_eq!(res, answer);
}

pub fn bin_length(proof: &[Vec<Vec<u8>>]) -> usize {
  proof.len() * 2
    + proof
      .iter()
      .map(|xs| xs.iter().fold(0, |acc, x| acc + x.len()) + xs.len() / 8)
      .fold(0, |acc, val| acc + val)
}
